\documentclass[a4paper,10pt]{article}

\usepackage{booktabs}
\usepackage{dirtree}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subfig}
\usepackage{varioref}
\usepackage{hyperref}

\newcommand{\libsf}{\textsf{libsf1r}}
\newcommand{\sfr}{\textsf{SF1}}
\newcommand{\code}[1]{\textsf{#1}}

\title{Documentation for the \libsf\ library}
\author{Paolo D'Apice}
\date{\today}

\makeatletter 
\newcommand\mynobreakpar{\par\nobreak\@afterheading} 
\makeatother

\begin{document}
\lstset{basicstyle=\sffamily}

\maketitle

\begin{abstract}
This document contains the detailed description of the \libsf\ library 
included in the izenelib project. The library provides two client drivers
for the \sfr\ search engine.
\end{abstract}

\tableofcontents

\section{Introduction}

The \libsf\ provides two C++ client drivers for the \sfr, namely:
\begin{description}
 \item[single] for connecting to a single \sfr\ instance (Figure~\vref{fig:scheme-single})
 \item[distributed] for connecting to a cluster of \sfr\ instances
                    registered with a ZooKeeper server (Figure~\vref{fig:scheme-distributed})
\end{description}

\begin{figure}
 \centering
 \subfloat[Single driver]
  {\label{fig:scheme-single}
  \includegraphics[width=.5\textwidth]{single-scheme}} \\
 \subfloat[Distributed driver]
  {\label{fig:scheme-distributed}
  \includegraphics[width=.6\textwidth]{distributed-scheme}}
 \caption{\sfr\ driver scheme.}
\end{figure}

\section{The SF1 communication protocol}

The \sfr\ search engine accepts connections using the custom socket protocol
described in Table~\vref{tab:protocol}.

\begin{table}[p]
 \centering
 \caption{\sfr\ communication protocol.}
 \label{tab:protocol}
 \begin{tabular}{lccc}
 \toprule
 \textbf{field} & sequence number & message length & message body\\
 \midrule
 \textbf{size} (bytes) & 4 & 4 & variable \\
 \bottomrule
 \end{tabular}
\end{table}

The custom protocol requires the following information:
\begin{description}
  \item[sequence number] non-zero unsigned integer associating 
                        a request and a response
  \item[message length] unsigned integer
  \item[message body] sequence of characters
\end{description}

The actual message body can be in one of the following formats:
\begin{itemize}
 \item JSON
\end{itemize}

% TODO: references

\section{Implementation details}

\subsection{Architecture}

The main software architecture is depicted in Figure~\vref{fig:composite}.
\begin{figure}[htb]
 \centering
 \includegraphics[width=.7\textwidth]{composite}
 \caption{Composite structure diagram.}
 \label{fig:composite}
\end{figure}
The following modules are defined:
\begin{description}
 \item[\code{RawClient}] sends requests to and receives responses from an \sfr\ 
                         instance via socket
 \item[\code{Writer}] interface for read and write operations on the message 
                      body for pre/post processing operations
 \item[\code{PoolFactory}] factory for the connection pools to an \sfr\ instance
 \item[\code{ConnectionPool}] of re-usable \code{RawClient} instances; 
                              the pool can be configured to be fixed-sized or to 
                              automatically grow its size up to an upper limit
 \item[\code{ZooKeeperRouter}] implements a topology monitor for the nodes 
                               actually registered with the ZooKeeper server; 
                               it also realizes an active router to the 
                               running \sfr\ instances
 \item[\code{Sf1Node}] represents a running \sfr\ instance registered with ZooKeeper
 \item[\code{Sf1Topology}] provides several views on the actual topology registered 
                    with ZooKeeper, allowing accessing a node directly or by
                    through its hosted collections
 \item[\code{Sf1Watcher}] event handler for changes in the ZooKeeper registered nodes
 \item[\code{RoutingPolicy}] interface for the routing policies used for request forwarding
\end{description}
The classes implementing the aforementioned components are shown 
in Figure~\vref{fig:classes}.
\begin{figure}
 \centering
 \includegraphics[width=\textwidth]{class}
 \caption{Class diagram.}
 \label{fig:classes}
\end{figure}

\subsection{Provided interface}

The \sfr\ driver exposes the following interface:
\begin{lstlisting}[language=C++,frame=single]
 std::string 
 call(const std::string& uri, 
      const std::string& tokens, 
            std::string& request) 
 throw(std::runtime_error); 
\end{lstlisting}
where:
\begin{description}
 \item[\code{uri}] is the URI of the request, in the format \code{/controller/action}
 \item[\code{tokens}] optional tokens to be sent to the \sfr
 \item[\code{request}] the message body
\end{description}

\subsection{Behavior}

The general behavior of the driver is depicted in Figure~\vref{fig:behavior}.
\begin{figure}
 \centering
 \includegraphics[width=.25\textwidth]{behavior}
 \caption{Activity diagram.}
 \label{fig:behavior}
\end{figure}
During the preprocessing stage, the request is modified in such a way that it
contains both the controller and the action specified in the URI.
Then a connection is obtained either directly from the connection pool 
(single driver, Fig.~\vref{fig:single}) or through ZooKeeper 
(distributed driver, Fig.~\vref{fig:distributed}).
In the latter case the \code{ZooKeeperRouter} acts as a proxy to the \code{ConnectionPool}.

\begin{figure}
 \centering
 \subfloat[Object diagram]{\includegraphics[width=.45\textwidth]{single-objects}}
 \\
 \subfloat[Sequence diagram]{\includegraphics[width=\textwidth]{single-sequence}}
 \caption{Single driver details.}
 \label{fig:single}
\end{figure}

\begin{figure}
 \centering
 \subfloat[Object diagram]{\includegraphics[width=.8\textwidth]{distributed-objects}}
 \\
 \subfloat[Sequence diagram]{\includegraphics[width=\textwidth]{distributed-sequence}}
 \caption{Distributed driver details.}
 \label{fig:distributed}
\end{figure}

For the distributed driver, the information contained in the request are used
in order to retrieve a proper \sfr\ instance from the actual topology.
For example, the \code{collection} parameter can be used to route a request only
to the \sfr\ instances actually hosting such collection.

\begin{figure}
 \centering
 \includegraphics[width=.9\textwidth]{distributed-sequence2}
 \caption{Sequence diagram for the \texttt{ZooKeeperRouter}.}
 \label{fig:distributed-sequence2}
\end{figure}

\subsection{ZooKeeper interaction}

\subsubsection*{Topology}

The distributed driver uses ZooKeeper for tracking the actual topology, which
is implemented using different containers (see Figure~\vref{fig:topology}):
\begin{description}
 \item[\code{NodeContainer}] a multi-index container providing two ways of 
                             accessing a node:
 \begin{itemize}
  \item by its ZooKeeper path\footnote{The ZooKeeper hierarchical namespace on 
        which \sfr\ instance are registered is defined as:
\dirtree{%
.1 /.
.2 SF1R-host.
.3 SearchTopology.
.4 ReplicaN [node count].
.5 NodeM [node data].
}}
  \item by its index number (used for random access and for iterations)
 \end{itemize}
 \item[\code{NodeCollectionsContainer}] a multimap associating a collection and the
                                        nodes where it currently is hosted
 \item[\code{CollectionsIndex}] a set of all the collections actually served by the \sfr\ cluster
\end{description}
All these containers need to be synchronized in order to be consistent with 
actual topology.
\begin{figure}
 \centering
 \includegraphics[width=.8\textwidth]{topology-class}
 \caption{\sfr\ topology implementation.}
 \label{fig:topology}
\end{figure}

\subsubsection*{Event handling}

On startup, the ZooKeeper client launches two threads, one for the I/O 
operations with the server, and one for event handling.
The watcher registered for event handling will then notify the router for 
topology changes. The \code{Sf1Watcher} responds to the following events:
\mynobreakpar
\begin{description}
 \item[node creation] the new \sfr\ node is added to the topology and a new 
                      connection pool is created
 \item[node data changed] the topology is updated in order to mirror node 
                          changes (e.g. the collections hosted)
 \item[node deletion] the \sfr\ node is removed from the topology, so that
                      no request will be forwarded to it, and its connection
                      pool is closed
 \item[node children changed] the hierarchical namespace must be watched in 
                              order to correctly detect the topology changes
\end{description}
In Figure~\vref{fig:zookeeper} is described how the topology is loaded.
Topology changes are monitored in the same way, e.g. when a \sfr\ has been
deleted from the ZooKeeper namespace, its corresponding \code{Sf1Node} is 
removed from topology and its \code{ConnectionPool} closed.

\begin{figure}
 \centering
 \includegraphics[width=.5\textwidth]{zookeeper-activity}
 \caption{Activity diagram for topology.}
 \label{fig:zookeeper}
\end{figure}

It is worth reminding that threads synchronization mechanism are required 
in order to access resource shared among threads.
Please refer to the ZooKeeper documentation for more details.
\end{document}

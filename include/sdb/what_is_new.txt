
INTRODUCTION
============

This document describes the changes from a previous version.
=============================================================

    Changes of sdb-v1

    =====================================================
        2008.11.13


        - All testing srcs are added.

        - Testing script sf1lib_test.pl is added.


        2008.10.29

        SequentialDB

        - Add overflow mechannism.

        - Modify SDB::initialize(...) method,
        The client can use default overflow page size.

            - SDBException added.

            Changes from version 0.2 to 0.2.1
            ===================================
                2008-10-08

                SequentialDB

                -  The efficiency SequentialDB been greatly improved.

                On contrast to BerkekeyDB, 	SequentialDB is faster than  BerkeleyDB when random
                writing and reading, whereas SequentialDB is slower than BerkeleyDB when ascending
                writing and reading.Moreover, SequentialDB outperforms BerkekeyDB greatly with with
                complex DataType and user defined comparison function.

                - Change SmartPtr.h to SmartPtr.h SmartPtr.cc to make it compatible with boost_1.36.0

                - Bechmark shows that SequentialDB_0.2.1 is more efficient than SequntialDB_0.3.1. SequentialDB_0.2.1 is
                recommended for use.


                Changes from version 0.2 to 0.3
                ===============================
                    2008-09-04

                    SequentialDB

                    -  Add feature:
key-value detachment option.

It stores key-value pair in SDB. But many times only the key part is needed in memory.
And the value part can be loaded when it is needed, eg, getValue(). And by this way,
when the value part is very large. it can improve cache efficency.

Add method

SequentialDB::void unloadValue()

It writes back the dirty page to disk and only keeps key part in memory.

SequentialDB::void setIsLoadValue(bool is);

If it is not isLoadValue is not set, it use default value true and it peforms as version 0.2.

    - Now it is compatible with Boost_1_36_0.

    In SmartPtr.h, intrusive_ptr_add_ref() and intrusive_ptr_release() are not template.

    - Bug are fixed in IndexSDB.



    Changes from version 0.1 to 0.2
    ======================================
    2008-08-28

    SequentialDB

    - Add method

    SequentialDB::getNearest(const KeyType& key)
    - If the key not exist in SequentialDB, it gets the smallest key that bigger than it.
    SequentialDB::getNext(const KeyType& key)
    SequentialDB::getPrev(const KeyType& key)

    [internal change]
    BTreeFile::getNearest(const KeyType& key)
    BTreeFile::getNext(const KeyType& key)
    BTreeFile::getPrev(const KeyType& key)

    BTreeNode::findPos1(KeyType& key)
{
    for BTreeFile::getNearest(const KeyType& key).
    }

- Now SequentialDB must be initialized to be used, see SequntialDB:
initialize() method.

----------------------------------------------
void initialize(unsigned int maxDataSize, unsigned int cacheSize)
{
    btFile_.setPageSize(maxDataSize);
    btFile_.setCacheSize(cacheSize);
    assert(btFile_.open());
}
----------------------------------------------
We assume DataType as,

struct DataType
{
    KeyType key;
    T       data;
}

maxDataSize:
it means the size of DataType's data  mustn't exceed it, or disaster would happen!
cacheSize:
it means the number of active BTreeNode in memory. The larger the better, default is 1000,000.

    - Now YString is serizable.

    ***********************************
    2008-08-28

    IndexSDB

    - Add method:

bool add(const KeyType& key, const ElementType& item);

void getValueIn(const vector<KeyType>& vKey, vector<ElementType>& result);
void getValueGreat(const KeyType& key, vector<ElementType>& result);
void getValueGreatEqual(const KeyType& key, vector<ElementType>& result);
void getValueGreatLess(const KeyType& key, vector<ElementType>& result);
void getValueGreatLessEqual(const KeyType& key, vector<ElementType>& result);
bool getValueBetween(const KeyType& lowKey, const KeyType& highKey,	vector<ElementType>& result);
void getValuePrefix(const KeyType& key, vector<ElementType>& result);

Note that, to use getValuePrefix() method, KeyType should have isPrefix(otherkey) method.


- Make substring pattern match avaible.

Use another IndexSDB to store every suffix of key's string.
eg, word "izene", have suffix "e", "ne", "ene", "zene" "izene".
And we should store 5 key-value pair, "e->izene", "ne->izene", "ene->izene", "izene->izene".

After finish process all the input words, We can get all the words with given substring by calling

void getValuePrefix(const KeyType& key, vector<ElementType>& result)


==========================
2008-08-25

- Support  different KeyType and DataTypes effectively with boost::serialization. And now all classes are in template  template parameters.
Note that, client can provide their own serialization method for their own DataType beside boost::serialization. See Wrapper.h.

- Use boost:intrusive_ptr to replace original smart_ptr. Don't need to worry memory leakage.

- Implement writing-back policy. Make sure non-dirty page not be written back and dirty page be written back only once.
Moreover writing-back only occures when calling BTreeFile::flush(). By this way, it maximizes memory/cache efficency.

- Make caching mechanism works. Now cache size means the number of active BTreeNodes in memory. When the active
nodes # exceed cache size. It will unload the nodes from the leaf level up until the active nodes # is less than
half of cache size. Note that, tt still keeps half nodes of top level at memory for fast access. See BTreeFiel::flush() method.

    - Implement IndexSDB is to support IndexerManager with TermID -> vector<DocID> as Key-Value pair. Normally the size of Value
    can be very small or very large. And it will be low efficency and waste a lot of disk space  if we use original SequentialDB
    by setting very large page-size.

    [solution]

Define underlying DataType as:

        template<KeyType, ElementType>
struct DataType
{
    struct
    {
        KeyType key;
        int offset;
    }subKey;
    vector<ElementType> subData;
};

It uses several subkeys to represent one key and original vector<ElementType> data are stored at sequential nodes.

- Add Update(const KeyType& key, const DataType &data) Method.
- Add GetValueBetween(vector<DataType>& result, const KeyType & lowKey, const KeyType & highKey) method.

- Thoroughly Testing, including writing-back policy and cache mechanism and new method.

- Bug fixes in

BTreeFile::_delete(keyType& key)
BTreeFile::_merge(KeyType& key)

where childNo and parent of modified nodes are not correclty assigned.


TO DO
=============

    -  Further Improvement. eg, BTreeNode::findPos(cosnt KeyType & key) seems able to be improved, and so on.


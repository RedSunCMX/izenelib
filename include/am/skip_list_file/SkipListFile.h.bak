/**
 * @file SkipListFile.h
 * @brief The header file of SkipListFile class.
 */
#ifndef _SkipListFile_H_
#define _SkipListFile_H_

#include "SlfHeader.h"
#include "SkipNode.h"
#include "MemMap.h"

#include <iostream>
#include <sys/stat.h>
#include <fstream>
#include <queue>
#include <set>
#include <am/concept/DataType.h>

using namespace std;

NS_IZENELIB_AM_BEGIN

#define KEY element.get_key()

/**
 * @brief The definition and implementation of the
 *        SkipList(Actually, it is a deterministic skip list)
 */
template<typename KeyType, typename ValueType=NullType, typename LockType=NullLock, typename Alloc=std::allocator<DataType<KeyType,ValueType> > >class SkipListFile
: public AccessMethod<KeyType, ValueType, LockType, Alloc>
{
	typedef DataType<KeyType, ValueType> DataType;
	typedef SkipNode<DataType, LockType, Alloc> SkipNode;
public:
	SkipListFile(const std::string& fileName, const size_t& minDegree = 2);
	virtual ~SkipListFile();

	void setPageSize(size_t maxDataSize, size_t overFlowSize) {
		maxDataSize_ = maxDataSize;
		size_t pageSize = sizeof(int) + MAX_LEVEL*sizeof(long) + maxDataSize;

		//	size_t pageSize = sizeof(byte) + 4*sizeof(long) + maxDataSize;

		sfh_.pageSize = pageSize;
		sfh_.overFlowSize = overFlowSize;

		SkipNode::setDataSize(maxDataSize,
				pageSize, overFlowSize);
	}

	/**
	 * 	\brief return the file name of the SequentialDB
	 */
	std::string getFileName() const {
		return fileName_;
	}

	/**
	 * 	We would peroidically flush the memory items, according to the cache Size. 
	 */

	void setCacheSize(size_t sz) {
		sfh_.cacheSize = sz;
	}

	/*	const DataType* find_min() const {
	 if (is_empty() )
	 return DataType();

	 SkipNode *current = header_;
	 while (current->down) {
	 current->loadDown(dataFile_);
	 current = current->down;
	 }
	 DataType* pd = new DataType( current->rgiht->element );

	 return pd;
	 }*/

	/*const DataType* find_max() const {
	 if (is_empty() )
	 return DataType();

	 SkipNode *current = header_;
	 for (;;) {
	 if (current->right != NULL)
	 current = current->right;
	 else if (current->down != NULL)
	 current = current->down;
	 else {
	 DataType* pd = new DataType( current->element );
	 return pd;
	 }
	 }
	 return 0;
	 }*/

	ValueType* find(const KeyType& x);
	/*ValueType* find(const KeyType& x) {
		return (ValueType*)((const SkipListFile*)this)->find(x);
	}*/

	/**
	 *  \brief updata an item with given key, if it not exist, insert it directly. 
	 */
	bool update(const KeyType& key, const ValueType& val) {
		return update(DataType(key, val) );
	}

	/**
	 *  \brief updata an item with given key, if it not exist, insert it directly. 
	 */
	bool update(const DataType& rec) {
		if( find (rec.get_key() ) ) {
			//to be implemented
		}
		else {
			return insert(rec);
		}
		return true;
	}

	bool is_empty() const;
	void print_list() const;

	int num_items() const {
		return sfh_.numItem;
	}
	void release();
	void release(SkipNode * ph);
	bool insert(const KeyType& key, const ValueType& value)
	{
		return insert( DataType(key, value) );
	}
	bool insert(const DataType& x);

	bool del(const KeyType& x);

	/**
	 * 	\brief get the next item.
	 */
	//bool seq(NodeKeyLocn& locn, DataType& rec, ESeqDirection sdir = ESD_FORWARD) {

	//}

	/**
	 *  \brief given a  key, get next key
	 */
	KeyType getNext(const KeyType& key) {

	}

	/**
	 *  \brief given a  key, get next key
	 */
	KeyType getPrev(const KeyType& key) {

	}
	void commit() {
		//cout<<"commiting... "<<endl;
		//sfh_.headerPos = header_->fpos;
		sfh_.toFile(dataFile_);

		//sfh_.display();

		/*	for(int i=0; i<(int)sfh_.nNode; i++) {
		 cout<<"commit node: "<<i<<endl;
		 nodeMap_[i]->write(dataFile_);
		 }*/

		while ( !dirtyPages_.empty() ) {
			SkipNode* p = dirtyPages_.back();
			//p->display();
			dirtyPages_.pop_back();
			p->write(dataFile_);
		}
		for(vector<MemBlock*>::iterator it=mbList.begin(); it !=mbList.end(); it++ ) {
			if(*it)(*it)->flush(dataFile_);
		}

	}

	void flush() {
		commit();
		//cout<<"commit finised\n"<<endl;
		//	SkipNode *ph = header_;
		//	vector<SkipNode*> headers;

		/*	while( ph != SkipNode::bottom ) {
		 headers.push_back( ph );
		 ph = ph->down;
		 }*/

		vector<MemBlock*>::iterator it, it1;
		for(it=mbList.begin(); it != mbList.end(); it++ ) {
			it1 = it;
			delete (*it1);
			*it1 = 0;
		}
		//cout<<"sdfsf "<<headers.size()<<endl;
		/*	while ( !headers.empty() ) {
		 if (SkipNode::activeNodeNum
		 < sfh_.cacheSize/2 && isUnload_) {
		 #ifdef DEBUG
		 cout<<"AcitveNodeNum= "
		 <<SkipNode::activeNodeNum
		 <<"\n stop unload\n";
		 #endif

		 break;
		 }
		 //SkipNode* ph = headers.back();
		 //headers.pop_back();
		 //release( ph );
		 }*/

	}

	void display() {
		print_list();
	}

	bool open() {
		// We're creating if the file doesn't exist.
		struct stat statbuf;
		bool creating = stat(fileName_.c_str(), &statbuf);

		dataFile_ = fopen(fileName_.c_str(), creating ? "w+b" : "r+b");
		if ( 0 == dataFile_) {
			cout<<"Error in open(): open file failed"<<endl;
			return false;
			//throw( SkipListFileException(OPEN_FILE_ERROR);
		}
		// Create a new node
		bool ret = false;
		if (creating) {

#ifdef DEBUG
			cout<<"creating...\n"<<endl;
			sfh_.display();
#endif

			// when creating, write the node to the disk.
			// remember that the first four bytes contain
			// the address of the root node.			

			// If creating, allocate a node instead of
			// reading one.
			header_ = allocateNode_();
			header_->height = 1;
			//sfh_.headerPos = header_->fpos;
			sfh_.toFile(dataFile_);

			dirtyPages_.push_back(header_);
			ret = true;
		} else {
			if ( !sfh_.fromFile(dataFile_) ) {
				return false;
			} else {
				if (sfh_.magic != 0x061561) {
					cout<<"Error, read wrong file header_\n"<<endl;
					return false;
				}
#ifdef DEBUG
				cout<<"open exist...\n"<<endl;
				sfh_.display();
#endif

				mbList.resize( sfh_.nNode/BLOCK_SIZE+1 );
				header_ = new SkipNode;
				header_ -> fpos = sfh_.headerPos;
				header_ -> read(dataFile_);

				//header_->display();
				ret = true;

			}
			// If note creating, just create and read
			// rather than allocating.
		}

		SkipNode::setDataSize(maxDataSize_,
				sfh_.pageSize, sfh_.overFlowSize);
		return ret;

	}

private:
	//const DataType m_infinity;
	SkipNode *header_; // The list
	//SkipNode *tail;
	//int num;

private:
	string fileName_;
	size_t minDegree_;
	FILE* dataFile_;

	SlfHeader sfh_;
	size_t maxDataSize_;

private:
	bool isUnload_;
	vector<SkipNode*> dirtyPages_;

	CompareFunctor<KeyType> comp_;

private:
	//map<int, MemBlock*> memMap_;

	//cache effectness?
	map<int, SkipNode*> nodeMap_;

private:

	/**
	 * 	 \brief open the database. 
	 *   \return if open successfully, return true, otherwise return false.
	 * 
	 *   Everytime  we use the database, we mush open it first.  
	 */

	void flushCache_() {
		if (SkipNode::activeNodeNum
>				sfh_.cacheSize) {
#ifdef DEBUG
			cout<<"flush ... "<<sfh_.cacheSize << endl;
			cout<<"activeNode: " <<SkipNode::activeNodeNum
			<<endl;
#endif
			isUnload_ = true;
			flush();
		}

	}

	SkipNode* allocateNode_() {

		SkipNode* newNode;
		newNode = new SkipNode;

		//fseek(dataFile_, 0L, SEEK_END);
		//long len = ftell(dataFile_);
		//newNode->fpos = len;

		newNode->isLoaded = true;
		newNode->height = 0;
		newNode->nid = sfh_.nNode;

		//	nodeMap_.insert( make_pair(newNode->nid, newNode) );
		newNode->fpos = sizeof(SlfHeader) + sfh_.pageSize*sfh_.nNode;

		/*if( sfh_.nNode % BLOCK_SIZE == 0){
		 MemBlock* newBlock = new MemBlock( sizeof(SlfHeader)+ sfh_.pageSize*sfh_.nNode, sfh_.pageSize);
		 mbList.push_back( newBlock );
		 }*/
		if( sfh_.nNode % BLOCK_SIZE == 0) {
			mbList.resize( sfh_.nNode/BLOCK_SIZE+1 );
		}
		sfh_.nNode++;

		return newNode;
	}

	SkipNode* search_(const KeyType& key, vector<SkipNode*>& update) {
		SkipNode* x = header_;
		int h = x->height-1;
		if (sfh_.numItem == 0)
		return false;
		while ( h>=0 ) {
			x->loadRight(h, dataFile_);
			while (x->right[h] && x->right[h]->height >= h && comp_(key, x->right[h]->KEY)> 0 )
			{	
				x = x->loadRight(h, dataFile_);
				if(x->right[h])x->loadRight(h, dataFile_);
			}
			update.push_back(x);
			if( x->right[h] && comp_( key, x->right[h]->KEY) == 0 ) {
				return x->right[h];
			}
			--h;
		}
		return 0;

	}

	void promote_(SkipNode* x, vector<SkipNode*>& update) {
		//	int tb = totalBand(sfh_.numItem);

		//protome to the top
		int h = x->height;
		int wb = whichBand(sfh_.height - x->height);
		//int toh = sfh_.height-1;
		int towb = 1;
		if(wb == towb) return;

		SkipNode* temp = update.back();
		update.pop_back();
		temp->counter[wb]--;
		h++;
		while( !update.empty() ) {
			temp = update.back();
			update.pop_back();
			x->right[h-1] = temp->right[h-1];
			temp->right[h-1] = x;
			temp->counter[wb]--;
			if( whichBand(sfh_.height-h) == towb ) {
				temp->counter[towb]++;
			}
			h++;
		}
		x->counter[wb] = x->counter[wb]+x->right[ x->height-vBandHeightAcc[wb]+1 ]->counter[wb]-1;
		for(int b=wb+1; b<=towb; b++) {
			x->counter[wb] = x->right[ x->height-vBandHeightAcc[wb]+1 ]->counter[wb]+1;
		}
		x->height = sfh_.height-1;
		
		display();

		/*typename
		 vector<SkipNode*>::iterator it = update.begin();	
		 
		 for(int i=th-2; i>x->height; i--)
		 {
		 SkipNode* p = *it;
		 it++;
		 
		 x->right[i] = p->right[i];
		 x->rfpos[i] = p->rfpos[i];
		 
		 p->right[i] = x;
		 p->rfpos[i] = x->fpos;		

		 dirtyPages_.push_back(x);
		 dirtyPages_.push_back(p);			
		 }
		 
		 x->height = th-1;*/

	}
	void demote_(int fromBand, int toBand) {
		if(fromBand >= toBand)return;
		for(int b=fromBand; b<toBand; b++)
		{
			SkipNode* p = randomSelect_(b);
			vector<SkipNode*> vs_before, vs_after;
			typename vector<SkipNode*>::iterator it;
			search_(p->KEY, vs_before);
			for(it=vs_before.begin();it != vs_before.end(); it++)
			{
				(*it)->counter[fromBand]--;
			}
		
			p->height -= vBandHeightAcc[toBand]-vBandHeightAcc[fromBand];
			search_(p->KEY, vs_after);
			
			it = vs_after.begin();
			(*it)->counter[toBand]++;		
			int h = (*it)->height;
			for(++it; it != vs_after.end(); it++)
			{
				(*it)->counter[toBand]++;				
				if( (*it)->right[h] == p ){
					(*it)->right[h] = p->right[h-1];	
					p->right[h] = 0;					
				}
				h--;				
			}			
			
			display();
		}
	}

	SkipNode * randomSelect_(int band) {
		SkipNode* x = header_;
		SkipNode* s;
		SkipNode* s1;
		int c, c1;
		int h = x->height-1;
		int acc = 0;
		while( h>=0 ) {
			s = x;
			if( s->right[h] ) {
				s1 = s->loadRight(h, dataFile_);
				c = s->counter[h];
				c1 = s1->counter[h];
				if( rand()% c < c1 )s = s->loadRight(h,dataFile_);
				else {
					h--;acc++;
				}
			}
			else {
				h--;acc++;
			}
			cout<<acc<<" >= "<<vBandHeightAcc[band]<<endl; 
			if( acc >= vBandHeightAcc[band] )
				cout<<" randomSelect = "<< s->KEY<<" with h="<<h<<endl;
			return s;
		}
	}

};

/**
 * @brief Find item x in the tree.
 *
 * Return the matching item or m_infinity if not found.
 */

template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> ValueType * SkipListFile<KeyType, ValueType,
		LockType, Alloc>::find(const KeyType & key)  {

	SkipNode* x = header_;
	int h = x->height-1;
	if (sfh_.numItem == 0)
		return false;
	vector<SkipNode*> update;
	while (h>=0) {
		x->loadRight(h, dataFile_);
		while (x->right[h] && comp_(key, x->right[h]->KEY)> 0 )
		{	x = x->loadRight(h, dataFile_);
			if(x->right[h])x->loadRight(h, dataFile_);
		}
		update.push_back(x);
		if( x->right[h] && comp_( key, x->right[h]->KEY) == 0 ) {
			promote_(x->right[h], update);
			int fromBand = 1;
			int toBand = whichBand(h);
			demote_(fromBand, toBand);
			ValueType* pv = new ValueType( x->right[h]->element.get_value() );
			return pv;
		}
		--h;
		//x = x->loadDown(dataFile_);
	}
	return 0;
}

/**
 * @brief Construct the tree.
 *
 * inf is the largest DataType
 * and is used to signal failed finds.
 */
template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> SkipListFile<KeyType, ValueType, LockType, Alloc>::SkipListFile(
		const string& fileName, const size_t& degree) :
	fileName_(fileName), minDegree_(degree) {

	isUnload_ = false;
	sfh_.degree = degree;

	//SkipNode::bottom = new SkipNode;
	//SkipNode::bottom->right = SkipNode::bottom->down = SkipNode::bottom;
	//open_();

}

/**
 * @brief Destructor.
 */
template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> SkipListFile<KeyType, ValueType, LockType, Alloc>::~SkipListFile() {
	release();
	//header_->unload();
	//header_ = 0;
	//delete SkipNode::bottom;
	//SkipNode::releaseBottom();
}

/**
 * @brief Insert item x into the SkipList.
 */
template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> bool SkipListFile<KeyType, ValueType, LockType, Alloc>::insert(
		const DataType& v) {

	SkipNode *t, *x;

	x = header_;
	int h = header_->height-1;

	vector<SkipNode*> update;

	while (h>=0) {
		x->loadRight(h, dataFile_);
		while (x->right[h] && comp_(v.get_key(), x->right[h]->KEY)> 0) {
			x = x->loadRight(h, dataFile_);
			x->loadRight(h, dataFile_);
		}
		update.push_back(x);
		if( x->right[h] && comp_( v.get_key(), x->right[h]->KEY) == 0 ) {
			/*promote_(x->right[h],update);
			 int fromBand = 1;
			 int toBand = whichBand(h);
			 demote_(fromBand, toBand);*/
			return false;
		}
		--h;
	}

	int height = coin_flip(sfh_.degree);
	if( height >= header_->height ) {
		height = header_->height;
		++sfh_.height;
		++header_->height;
		dirtyPages_.push_back(header_);
		assert(header_->height <= MAX_LEVEL);
	}
	t = allocateNode_();
	t->element = v;
	t->height = height;

	//get band
	int b = whichBand(height);

	//SkipNode* y = SkipNode::bottom;
	typename
	vector<SkipNode*>::iterator it = update.end();
	--it;
	for(int i=0; i<height; i++)
	{
		SkipNode* p = *it;

		//also update counter.
		p->counter[b]++;
		it--;
		//update.back();	
		//update.pop_back();
		//if(right[i])
		t->right[i] = p->right[i];
		t->rfpos[i] = p->rfpos[i];

		//t->down = y;	
		p->right[i] = t;
		p->rfpos[i] = t->fpos;
		//cout<< p->rfpos[i]<<endl;

		dirtyPages_.push_back(t);
		dirtyPages_.push_back(p);
		//y = t;
	}

	/*if (header_->right[header_->height - 1] != NULL) {
	 header_->height++;
	 sfh_.height++;
	 dirtyPages_.push_back(t);
	 //cout<<"reach here 2"<<endl;
	 }*/

	sfh_.numItem++;
	return true;
}

template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> bool SkipListFile<KeyType, ValueType, LockType, Alloc>::del(
		const KeyType& key) {

	/*SkipNode* x = header_;
	 SkipNode* p;
	 while (x != SkipNode::bottom) {
	 while (x->right && comp_(key, x->right->KEY)> 0 ) {
	 x = x->loadRight(dataFile_);
	 }
	 if( !x )return 0;
	 if( x->right && key == x->right->KEY) {
	 while( x!= SkipNode::bottom ) {
	 //cout<<"!!!"<<endl;
	 x->isDirty = true;
	 dirtyPages_.push_back(x);
	 p = x->right;
	 x->right = p->right;
	 delete p;
	 p = 0;
	 //sfh_.nNode--;
	 x = x->loadDown(dataFile_);

	 }
	 sfh_.numItem--;
	 return true;
	 }
	 //if ( x->down == SkipNode::bottom)
	 //return (v == x->right->KEY) ? &( x->right->element.get_value() ) : 0;
	 x = x->loadDown(dataFile_);
	 }
	 if (header_->down->right = NULL) {
	 SkipNode* t = header_->down;
	 header_->down = t->down;
	 delete t;
	 sfh_.height--;
	 dirtyPages_.push_back(header_);
	 //cout<<"reach here 2"<<endl;
	 }*/
	return 0;

}

/**
 * @brief Find the smallest item in the tree.
 *
 * Return smallest item or m_infinity if empty.
 */

/*
 template <typename KeyType, typename ValueType, typename LockType,
 typename Alloc> const DataType* SkipListFile<KeyType, ValueType,
 LockType, Alloc>::find_min() const {
 if (is_empty() )
 return DataTyp();

 SkipNode *current = header_;
 while (current->down) {
 current->loadDown(dataFile_);
 current = current->down;
 }
 DataType* pd = new DataType( current->rgiht->element );

 return pd;
 }
 */

/**
 * @brief Find the largest item in the tree.
 *
 * Return the largest item or m_infinity if empty.
 */

/*
 template <typename KeyType, typename ValueType, typename LockType,
 typename Alloc> const DataType* SkipListFile<KeyType, ValueType,
 LockType, Alloc>::find_max() const {
 if (is_empty() )
 return DataType();

 SkipNode *current = header_;
 for (;;) {
 if (current->right != NULL)
 current = current->right;
 else if (current->down != Null)
 current = current->down;
 else {
 DataType* pd = new DataType( current->element );
 return pd;
 }
 }

 return 0;
 }
 */

/**
 * @brief Make the tree logically empty.
 */
template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> void SkipListFile<KeyType, ValueType, LockType, Alloc>::release() {
	//SkipNode* p = header_;
	//while( p )
	{
		//to do
		//should keep a list for caching
	}
	/*while (header_ != SkipNode::bottom) {
	 SkipNode *headDown = header_->down;
	 release(header_);
	 header_ = headDown;
	 }*/

	vector<MemBlock*>::iterator it, it1;
	for (it = mbList.begin(); it != mbList.end(); it++) {
		it1 = it;
		delete *it1;
	}
}

/**
 * @brief Make the tree logically empty.
 */
/*template <typename KeyType, typename ValueType, typename LockType,
 typename Alloc> void SkipListFile<KeyType, ValueType, LockType, Alloc>::release(
 SkipNode *ph) {
 //cout<<"release..."<<endl;
 SkipNode *right;
 while (ph) {
 if (ph)
 right = ph->right;
 else {
 break;
 }
 ph = right;
 }
 }*/

/**
 * @brief Test if the tree is logically empty.
 *
 * Return true if empty, false otherwise.
 */
template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> inline bool SkipListFile<KeyType, ValueType, LockType,
		Alloc>::is_empty() const {
	return (sfh_.numItem == 0);
}

/**
 * @brief Print the SkipList.
 */
template <typename KeyType, typename ValueType, typename LockType,
		typename Alloc> void SkipListFile<KeyType, ValueType, LockType, Alloc>::print_list() const {
	SkipNode *current = header_;
	header_->display();
	int h = header_->height-1;
	int a = 1;
	int b = 1;
	while (h>=0) {
		current = header_->right[h];
		while (current) {
			//temp = current->down;			
			cout<<current->element.get_key()<<"("<<current->height <<") -> ";
			if (vBandHeightAcc[b] == a) {
				cout<<"counter("<<b<<")="<<current->counter[b]<< endl;
				b++;
			}
			current = current->right[h];
		}
		cout<<" tail"<<endl;
		h--;
		a++;

	}
	//cout<<"Down"<<endl;
}

NS_IZENELIB_AM_END

#endif


\hypertarget{classsdb__btree}{
\section{sdb\_\-btree$<$ KeyType, ValueType, LockType, Alloc $>$ Class Template Reference}
\label{classsdb__btree}\index{sdb\_\-btree@{sdb\_\-btree}}
}
\hyperlink{classfile}{file} version of cc-b$\ast$-btree  


{\tt \#include $<$sdb\_\-btree.h$>$}

Inheritance diagram for sdb\_\-btree$<$ KeyType, ValueType, LockType, Alloc $>$::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classsdb__btree}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{CompactItemize}
\item 
\hypertarget{classsdb__btree_15a24f87a9a407de8b68ee054af3b54a}{
typedef sdb\_\-node\_\-$<$ KeyType, ValueType, LockType, Alloc $>$ \textbf{sdb\_\-node}}
\label{classsdb__btree_15a24f87a9a407de8b68ee054af3b54a}

\item 
\hypertarget{classsdb__btree_d6105a305901616127f769f0147a5e03}{
typedef DataType$<$ KeyType, ValueType $>$ \textbf{DataType}}
\label{classsdb__btree_d6105a305901616127f769f0147a5e03}

\item 
\hypertarget{classsdb__btree_6c8e77fb4c105a87903d11cb6b28f62c}{
typedef std::pair$<$ sdb\_\-node $\ast$, size\_\-t $>$ \textbf{SDBCursor}}
\label{classsdb__btree_6c8e77fb4c105a87903d11cb6b28f62c}

\end{CompactItemize}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hyperlink{classsdb__btree_ae55c86e49f1ff7c02f4251ccfe8c625}{sdb\_\-btree} (const std::string \&fileName=\char`\"{}sequentialdb.dat\#\char`\"{})
\begin{CompactList}\small\item\em constructor \item\end{CompactList}\item 
void \hyperlink{classsdb__btree_1f6eb93d26b290d3969de6503672ae07}{setBtreeMode} (bool delaySplit)
\begin{CompactList}\small\item\em set mod \item\end{CompactList}\item 
void \hyperlink{classsdb__btree_c393399c9c8b9a1f06ecb4f4cce15bf0}{setMaxKeys} (size\_\-t maxkeys)
\begin{CompactList}\small\item\em set the MaxKeys \item\end{CompactList}\item 
void \hyperlink{classsdb__btree_fc9d66b5f80ba33b114c5f4db70a8dc6}{setDegree} (size\_\-t degree)
\begin{CompactList}\small\item\em set maxKeys for fileHeader \item\end{CompactList}\item 
void \hyperlink{classsdb__btree_930cde276bf7ed268a7005ba92dfbf12}{setPageSize} (size\_\-t pageSize)
\begin{CompactList}\small\item\em set tha pageSize of fileHeader. \item\end{CompactList}\item 
void \hyperlink{classsdb__btree_a815f13cd8a7cf18a93190e6aa9c4efc}{setCacheSize} (size\_\-t sz)
\begin{CompactList}\small\item\em set Cache Size. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_85f5043da06823365665619cda9eebb2}{
std::string \hyperlink{classsdb__btree_85f5043da06823365665619cda9eebb2}{getFileName} () const }
\label{classsdb__btree_85f5043da06823365665619cda9eebb2}

\begin{CompactList}\small\item\em return the \hyperlink{classfile}{file} name of the SequentialDB \item\end{CompactList}\item 
bool \hyperlink{classsdb__btree_3930f68c0075a965d79dae75586e611d}{open} ()
\begin{CompactList}\small\item\em open the database. \item\end{CompactList}\item 
bool \hyperlink{classsdb__btree_2da914c45fec1081667fb22d42a021a5}{close} ()
\begin{CompactList}\small\item\em close the database. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_30e2c2e7489f8785c86284e09b75bcfb}{
bool \hyperlink{classsdb__btree_30e2c2e7489f8785c86284e09b75bcfb}{del} (const KeyType \&key)}
\label{classsdb__btree_30e2c2e7489f8785c86284e09b75bcfb}

\begin{CompactList}\small\item\em del an item from the database \item\end{CompactList}\item 
\hypertarget{classsdb__btree_3f3988638bc90b19230f5c80dd960dad}{
bool \hyperlink{classsdb__btree_3f3988638bc90b19230f5c80dd960dad}{insert} (const DataType \&rec)}
\label{classsdb__btree_3f3988638bc90b19230f5c80dd960dad}

\begin{CompactList}\small\item\em insert an item. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_1bc062c093b1b5599313bcf33af0820f}{
bool \hyperlink{classsdb__btree_1bc062c093b1b5599313bcf33af0820f}{insert} (const KeyType \&key, const ValueType \&value)}
\label{classsdb__btree_1bc062c093b1b5599313bcf33af0820f}

\begin{CompactList}\small\item\em insert an item. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_42fb2964951af3294e544f857f23349b}{
ValueType $\ast$ \hyperlink{classsdb__btree_42fb2964951af3294e544f857f23349b}{find} (const KeyType \&key)}
\label{classsdb__btree_42fb2964951af3294e544f857f23349b}

\begin{CompactList}\small\item\em find an item given a key. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_1fe7be112c01719109bf98f803777417}{
bool \textbf{get} (const KeyType \&key, ValueType \&value)}
\label{classsdb__btree_1fe7be112c01719109bf98f803777417}

\item 
\hypertarget{classsdb__btree_a4d71e716f6c61ff4f1f78317dcc9a17}{
const ValueType $\ast$ \hyperlink{classsdb__btree_a4d71e716f6c61ff4f1f78317dcc9a17}{find} (const KeyType \&key) const }
\label{classsdb__btree_a4d71e716f6c61ff4f1f78317dcc9a17}

\begin{CompactList}\small\item\em find an item given a key. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_cb2ca67cdc1d405212cfd2332b626cda}{
bool \hyperlink{classsdb__btree_cb2ca67cdc1d405212cfd2332b626cda}{update} (const KeyType \&key, const ValueType \&val)}
\label{classsdb__btree_cb2ca67cdc1d405212cfd2332b626cda}

\begin{CompactList}\small\item\em updata an item with given key, if it not exist, insert it directly. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_e0bab2b948984fcaae6d38f161fad06f}{
bool \hyperlink{classsdb__btree_e0bab2b948984fcaae6d38f161fad06f}{update} (const DataType \&rec)}
\label{classsdb__btree_e0bab2b948984fcaae6d38f161fad06f}

\begin{CompactList}\small\item\em updata an item with given key, if it not exist, insert it directly. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_4c3e3043ff613cb1f81d6c7d60279562}{
int \hyperlink{classsdb__btree_4c3e3043ff613cb1f81d6c7d60279562}{num\_\-items} ()}
\label{classsdb__btree_4c3e3043ff613cb1f81d6c7d60279562}

\begin{CompactList}\small\item\em get the number of the items. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_4796b30a0a456d6ff6f3c395f9a2647f}{
bool \hyperlink{classsdb__btree_4796b30a0a456d6ff6f3c395f9a2647f}{get} (const SDBCursor \&locn, DataType \&rec)}
\label{classsdb__btree_4796b30a0a456d6ff6f3c395f9a2647f}

\begin{CompactList}\small\item\em get an item from given Locn. $\ast$ \item\end{CompactList}\item 
\hypertarget{classsdb__btree_4e4408d7daafd2fcf1a1baeff8101765}{
bool \hyperlink{classsdb__btree_4e4408d7daafd2fcf1a1baeff8101765}{get} (const SDBCursor \&locn, KeyType \&key, ValueType \&value)}
\label{classsdb__btree_4e4408d7daafd2fcf1a1baeff8101765}

\begin{CompactList}\small\item\em get an item from given Locn. $\ast$ \item\end{CompactList}\item 
\hypertarget{classsdb__btree_0388b79df1693137217f884588e2e30d}{
SDBCursor \hyperlink{classsdb__btree_0388b79df1693137217f884588e2e30d}{get\_\-first\_\-locn} ()}
\label{classsdb__btree_0388b79df1693137217f884588e2e30d}

\begin{CompactList}\small\item\em get the cursor of the first item. \item\end{CompactList}\item 
bool \hyperlink{classsdb__btree_dfcd196457bcb4517403a6471a7076af}{seq} (SDBCursor \&locn, DataType \&rec, ESeqDirection sdir=ESD\_\-FORWARD)
\begin{CompactList}\small\item\em get the next or prev item. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_1e6e4ead81ba7d871919a601fd68c1e6}{
void \hyperlink{classsdb__btree_1e6e4ead81ba7d871919a601fd68c1e6}{flush} ()}
\label{classsdb__btree_1e6e4ead81ba7d871919a601fd68c1e6}

\begin{CompactList}\small\item\em write all the items in memory to \hyperlink{classfile}{file}. \item\end{CompactList}\item 
\hypertarget{classsdb__btree_4336e972867ad749ce98519fe5220bc5}{
void \hyperlink{classsdb__btree_4336e972867ad749ce98519fe5220bc5}{commit} ()}
\label{classsdb__btree_4336e972867ad749ce98519fe5220bc5}

\begin{CompactList}\small\item\em write back the dirypages \item\end{CompactList}\item 
void \hyperlink{classsdb__btree_b1f5ad2d92b57af57aca4a06c925bb16}{display} (std::ostream \&os=std::cout, bool onlyheader=true)
\item 
\hypertarget{classsdb__btree_cc591b9dee49543d1a39891f4af1b842}{
SDBCursor \hyperlink{classsdb__btree_cc591b9dee49543d1a39891f4af1b842}{search} (const KeyType \&key)}
\label{classsdb__btree_cc591b9dee49543d1a39891f4af1b842}

\begin{CompactList}\small\item\em Get the DB cursor of given key. \item\end{CompactList}\item 
bool \hyperlink{classsdb__btree_2761e4efefbe470ca5121c2eb19f6a6e}{search} (const KeyType \&key, SDBCursor \&locn)
\begin{CompactList}\small\item\em get the cursor for given key \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename KeyType, typename ValueType = NullType, typename LockType = NullLock, typename Alloc = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ class sdb\_\-btree$<$ KeyType, ValueType, LockType, Alloc $>$}

\hyperlink{classfile}{file} version of cc-b$\ast$-btree 

A B$\ast$-tree is a tree data structure used in the HFS and Reiser4 \hyperlink{classfile}{file} systems, which requires non-root nodes to be at least 2/3 full instead of 1/2. To maintain this, instead of immediately splitting up a node when it gets full, its keys are shared with the node next to it. When both are full, then the two of them are split into three. Now SDBv1.0â€™s disk space is large than BerkeleyDB when storing the same data set. There is a perspective that, B$\ast$-tree can save more disk space than normal btree.

For implementation convience and maintainess, we only apply this delay splitting at leaves nodes.

Merging will occur when two sibling nodes' objCount both less than maxKeys/3/ 

Definition at line 42 of file sdb\_\-btree.h.

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classsdb__btree_ae55c86e49f1ff7c02f4251ccfe8c625}{
\index{sdb\_\-btree@{sdb\_\-btree}!sdb\_\-btree@{sdb\_\-btree}}
\index{sdb\_\-btree@{sdb\_\-btree}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{sdb\_\-btree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType , typename LockType , typename Alloc $>$ {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::{\bf sdb\_\-btree} (const std::string \& {\em fileName} = {\tt \char`\"{}sequentialdb.dat\#\char`\"{}})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_ae55c86e49f1ff7c02f4251ccfe8c625}


constructor 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em fileName}]is the name for data \hyperlink{classfile}{file} if fileName ends with '\#', we set b-tree mode to not delay split. \end{description}
\end{Desc}


Definition at line 493 of file sdb\_\-btree.h.

\subsection{Member Function Documentation}
\hypertarget{classsdb__btree_2da914c45fec1081667fb22d42a021a5}{
\index{sdb\_\-btree@{sdb\_\-btree}!close@{close}}
\index{close@{close}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{close}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType  = NullType, typename LockType  = NullLock, typename Alloc  = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ bool {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::close ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_2da914c45fec1081667fb22d42a021a5}


close the database. 

if we don't call it, it will be automately called in deconstructor 

Definition at line 160 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_b1f5ad2d92b57af57aca4a06c925bb16}{
\index{sdb\_\-btree@{sdb\_\-btree}!display@{display}}
\index{display@{display}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{display}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType  = NullType, typename LockType  = NullLock, typename Alloc  = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ void {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::display (std::ostream \& {\em os} = {\tt std::cout}, \/  bool {\em onlyheader} = {\tt true})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_b1f5ad2d92b57af57aca4a06c925bb16}


for debug. print the shape of the B tree. 

Definition at line 317 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_3930f68c0075a965d79dae75586e611d}{
\index{sdb\_\-btree@{sdb\_\-btree}!open@{open}}
\index{open@{open}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{open}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType , typename LockType , typename Alloc $>$ bool {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::open ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_3930f68c0075a965d79dae75586e611d}


open the database. 

Everytime we use the database, we mush open it first. 

Definition at line 1237 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_2761e4efefbe470ca5121c2eb19f6a6e}{
\index{sdb\_\-btree@{sdb\_\-btree}!search@{search}}
\index{search@{search}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType , typename LockType , typename Alloc $>$ bool {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::search (const KeyType \& {\em key}, \/  SDBCursor \& {\em locn})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_2761e4efefbe470ca5121c2eb19f6a6e}


get the cursor for given key 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em locn}]is cursor of key. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]true if key exists otherwise false. \end{Desc}


Definition at line 516 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_dfcd196457bcb4517403a6471a7076af}{
\index{sdb\_\-btree@{sdb\_\-btree}!seq@{seq}}
\index{seq@{seq}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{seq}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType , typename LockType , typename Alloc $>$ bool {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::seq (SDBCursor \& {\em locn}, \/  DataType \& {\em rec}, \/  ESeqDirection {\em sdir} = {\tt ESD\_\-FORWARD})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_dfcd196457bcb4517403a6471a7076af}


get the next or prev item. 

when locn is default value, it will start with firt element when sdri=ESD\_\-FORWARD and start with last element when sdir = ESD\_\-BACKWARD 

Definition at line 1372 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_1f6eb93d26b290d3969de6503672ae07}{
\index{sdb\_\-btree@{sdb\_\-btree}!setBtreeMode@{setBtreeMode}}
\index{setBtreeMode@{setBtreeMode}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{setBtreeMode}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType  = NullType, typename LockType  = NullLock, typename Alloc  = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ void {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::setBtreeMode (bool {\em delaySplit})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_1f6eb93d26b290d3969de6503672ae07}


set mod 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em delaySplit,if}]true, the btree is cc-b$\ast$-btee, otherwise is normal cc-b-tree.\end{description}
\end{Desc}
For ascending insertion, cc-b-tree is much faster than cc-b$\ast$-btree, while cc-b$\ast$-btree uses less disk space and find faster than cc-b-btree. 

Definition at line 70 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_a815f13cd8a7cf18a93190e6aa9c4efc}{
\index{sdb\_\-btree@{sdb\_\-btree}!setCacheSize@{setCacheSize}}
\index{setCacheSize@{setCacheSize}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{setCacheSize}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType  = NullType, typename LockType  = NullLock, typename Alloc  = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ void {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::setCacheSize (size\_\-t {\em sz})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_a815f13cd8a7cf18a93190e6aa9c4efc}


set Cache Size. 

Cache Size is the active node number in memory.When cache is full, some nodes will be released.

We would peroidically flush the memory items, according to the cache Size. 

Definition at line 136 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_fc9d66b5f80ba33b114c5f4db70a8dc6}{
\index{sdb\_\-btree@{sdb\_\-btree}!setDegree@{setDegree}}
\index{setDegree@{setDegree}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{setDegree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType  = NullType, typename LockType  = NullLock, typename Alloc  = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ void {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::setDegree (size\_\-t {\em degree})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_fc9d66b5f80ba33b114c5f4db70a8dc6}


set maxKeys for fileHeader 

maxKeys is 2$\ast$degree Note that it must be at least 6 It can only be called before opened.And it doesn't work when open an existing dat \hyperlink{classfile}{file}, \_\-sfh.maxKeys will be read from \hyperlink{classfile}{file}. 

Definition at line 100 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_c393399c9c8b9a1f06ecb4f4cce15bf0}{
\index{sdb\_\-btree@{sdb\_\-btree}!setMaxKeys@{setMaxKeys}}
\index{setMaxKeys@{setMaxKeys}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{setMaxKeys}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType  = NullType, typename LockType  = NullLock, typename Alloc  = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ void {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::setMaxKeys (size\_\-t {\em maxkeys})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_c393399c9c8b9a1f06ecb4f4cce15bf0}


set the MaxKeys 

Note that it must be at least 6. It can only be called before open. And it doesn't work when open an existing dat \hyperlink{classfile}{file}, \_\-sfh.maxKeys will be read from \hyperlink{classfile}{file}. 

Definition at line 82 of file sdb\_\-btree.h.\hypertarget{classsdb__btree_930cde276bf7ed268a7005ba92dfbf12}{
\index{sdb\_\-btree@{sdb\_\-btree}!setPageSize@{setPageSize}}
\index{setPageSize@{setPageSize}!sdb_btree@{sdb\_\-btree}}
\subsubsection[{setPageSize}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename KeyType , typename ValueType  = NullType, typename LockType  = NullLock, typename Alloc  = std::allocator$<$DataType$<$KeyType,ValueType$>$ $>$$>$ void {\bf sdb\_\-btree}$<$ KeyType, ValueType, LockType, Alloc $>$::setPageSize (size\_\-t {\em pageSize})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classsdb__btree_930cde276bf7ed268a7005ba92dfbf12}


set tha pageSize of fileHeader. 

It can only be called before open.And it doesn't work when open an existing dat \hyperlink{classfile}{file}, \_\-sfh.pageSize will be read from \hyperlink{classfile}{file}.

It should set the pageSize according the maxKeys and max inserting data size. When pageSize is too small, overflowing will occur and cause efficiency to decline. When pageSize is too large, it will waste disk space. 

Definition at line 122 of file sdb\_\-btree.h.

The documentation for this class was generated from the following file:\begin{CompactItemize}
\item 
/home/Kevin/izenelib/include/am/sdb\_\-btree/\hyperlink{sdb__btree_8h}{sdb\_\-btree.h}\end{CompactItemize}

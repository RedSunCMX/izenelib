\hypertarget{classcccr__hash}{
\section{cccr\_\-hash$<$ KeyType, ValueType, ENTRY\_\-POW $>$ Class Template Reference}
\label{classcccr__hash}\index{cccr\_\-hash@{cccr\_\-hash}}
}
\hyperlink{classcccr__hash}{cccr\_\-hash} stands for Cache-Conscious Collision Resolution String Hash Table.  


{\tt \#include $<$cccr\_\-hash.h$>$}

Inheritance diagram for cccr\_\-hash$<$ KeyType, ValueType, ENTRY\_\-POW $>$::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classcccr__hash}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hypertarget{classcccr__hash_9f0e0f8eaf7370e7417e2fbaed88d6e6}{
bool \textbf{insert} (const DataType \&data)}
\label{classcccr__hash_9f0e0f8eaf7370e7417e2fbaed88d6e6}

\item 
\hypertarget{classcccr__hash_a4587ac348bd2b65186e5bddedd7c6a2}{
bool \textbf{update} (const DataType \&dat)}
\label{classcccr__hash_a4587ac348bd2b65186e5bddedd7c6a2}

\item 
\hypertarget{classcccr__hash_d9f201209fc37cc23afba5b07f47dbde}{
int \textbf{num\_\-items} () const }
\label{classcccr__hash_d9f201209fc37cc23afba5b07f47dbde}

\item 
\hypertarget{classcccr__hash_eddc7b7680bd29a9a17f859f291fd2da}{
void \textbf{display} (std::ostream \&os=std::cout)}
\label{classcccr__hash_eddc7b7680bd29a9a17f859f291fd2da}

\item 
\hypertarget{classcccr__hash_4016ceeb1d7fdbcb1b94132f838682f9}{
bool \textbf{insert} (const KeyType \&key, const ValueType \&v)}
\label{classcccr__hash_4016ceeb1d7fdbcb1b94132f838682f9}

\item 
\hypertarget{classcccr__hash_07d730bb1bf0c5eee4d82f1646432b30}{
ValueType $\ast$ \textbf{find} (const KeyType \&key)}
\label{classcccr__hash_07d730bb1bf0c5eee4d82f1646432b30}

\item 
\hypertarget{classcccr__hash_9a442ea53d9e4b6d429f54e6742a40be}{
bool \textbf{del} (const KeyType \&key)}
\label{classcccr__hash_9a442ea53d9e4b6d429f54e6742a40be}

\item 
\hypertarget{classcccr__hash_c5980ff3a6f52b8fcedd586598ca360b}{
bool \textbf{update} (const KeyType \&key, const ValueType \&v)}
\label{classcccr__hash_c5980ff3a6f52b8fcedd586598ca360b}

\end{CompactItemize}
\subsection*{Protected Attributes}
\begin{CompactItemize}
\item 
\hypertarget{classcccr__hash_bf34bf6bad9aa74a116546db8f584e43}{
char $\ast$ \textbf{entry\_\-} \mbox{[}ENTRY\_\-SIZE\mbox{]}}
\label{classcccr__hash_bf34bf6bad9aa74a116546db8f584e43}

\item 
\hypertarget{classcccr__hash_0e00a47602fb75b10ad2ffa93a98d53c}{
vector$<$ ValueType $>$ \textbf{dataVec\_\-}}
\label{classcccr__hash_0e00a47602fb75b10ad2ffa93a98d53c}

\item 
\hypertarget{classcccr__hash_bd2b6a257b9ca60385d9373a49b42a04}{
int \textbf{count\_\-}}
\label{classcccr__hash_bd2b6a257b9ca60385d9373a49b42a04}

\end{CompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename KeyType = string, typename ValueType = NullType, size\_\-t ENTRY\_\-POW = 17$>$ class cccr\_\-hash$<$ KeyType, ValueType, ENTRY\_\-POW $>$}

\hyperlink{classcccr__hash}{cccr\_\-hash} stands for Cache-Conscious Collision Resolution String Hash Table. 

This is based on work of Nikolas Askitis and Justin Zobel, 'Cache-Conscious Collision Resolution in String Hash Tables' .On typical current machines each cache miss incurs a delay of hundreds of clock cycles while data is fetched from memory. This approach both saves space and eliminates a potential cache miss at each node access, at little cost. In experiments with large sets of strings drawn from real-world data, we show that, in comparison to standard chaining, compact-chain hash tables can yield both space savings and reductions in per-string access times. 

Definition at line 25 of file cccr\_\-hash.h.

The documentation for this class was generated from the following file:\begin{CompactItemize}
\item 
/home/Kevin/izenelib/include/am/cccr\_\-hash/cccr\_\-hash.h\end{CompactItemize}

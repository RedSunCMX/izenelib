<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>iZENElib - A great library for text processing: Algorithm&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Algorithm&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt; Class Template Reference</h1><!-- doxytag: class="Algorithm" -->An string algorithm set.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="algo_8hpp-source.html">algo.hpp</a>&gt;</code>
<p>

<p>
<a href="classAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>StrCompMode</b> { <b>SM_SENSITIVE</b>, 
<b>SM_IGNORE</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf32909208409a7e9a44870688efd919"></a><!-- doxytag: member="Algorithm::get_nextval" ref="cf32909208409a7e9a44870688efd919" args="(const StringT &amp;s, uint64_t next[], StrCompMode caseChk=SM_SENSITIVE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_nextval</b> (const StringT &amp;s, uint64_t next[], StrCompMode caseChk=SM_SENSITIVE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#9f7fcee0cfbabce55c5a9cabb1868f29">KMP</a> (const StringT &amp;text, const StringT &amp;pattern, StrCompMode caseChk=SM_SENSITIVE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="207eb5ca98c395ebe066a44bf1a2d04f"></a><!-- doxytag: member="Algorithm::rget_nextval" ref="207eb5ca98c395ebe066a44bf1a2d04f" args="(const StringT &amp;s, uint64_t next[], StrCompMode caseChk=SM_SENSITIVE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rget_nextval</b> (const StringT &amp;s, uint64_t next[], StrCompMode caseChk=SM_SENSITIVE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#a3e24e19980c0dd29c80f9feff6e5191">rKMP</a> (const StringT &amp;text, const StringT &amp;pattern, StrCompMode caseChk=SM_SENSITIVE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8460fd980d7167c1b4a915204cc7df07"></a><!-- doxytag: member="Algorithm::to_integer" ref="8460fd980d7167c1b4a915204cc7df07" args="(const StringT &amp;str)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>to_integer</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="509971d56fef622fb2a932282b6e49ee"></a><!-- doxytag: member="Algorithm::to_long" ref="509971d56fef622fb2a932282b6e49ee" args="(const StringT &amp;str)" -->
static long&nbsp;</td><td class="memItemRight" valign="bottom"><b>to_long</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f782d0117e525f350cbc2a6b9766737a"></a><!-- doxytag: member="Algorithm::to_ulong" ref="f782d0117e525f350cbc2a6b9766737a" args="(const StringT &amp;str)" -->
static unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>to_ulong</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c702274e3932a6a3cc897fa8295c9d2f"></a><!-- doxytag: member="Algorithm::to_float" ref="c702274e3932a6a3cc897fa8295c9d2f" args="(const StringT &amp;str)" -->
static float&nbsp;</td><td class="memItemRight" valign="bottom"><b>to_float</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67299838db627baf19ef206e7f614e61"></a><!-- doxytag: member="Algorithm::to_lower" ref="67299838db627baf19ef206e7f614e61" args="(StringT &amp;str)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>to_lower</b> (StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#42e06428b21a425ac2da8d60313ab9a9">to_upper</a> (StringT &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change all the lower case to upper caes in the _text.  <a href="#42e06428b21a425ac2da8d60313ab9a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#617415dba55cc4533e4776760178032b">to_lower</a> (const StringT &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change all the upper case to lower case in the _text.  <a href="#617415dba55cc4533e4776760178032b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98f7e6214b85d3d3ee160561e09cd5e5"></a><!-- doxytag: member="Algorithm::to_upper" ref="98f7e6214b85d3d3ee160561e09cd5e5" args="(const StringT &amp;str)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>to_upper</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="444f53fac69e2f1e91b9b300177d2b4f"></a><!-- doxytag: member="Algorithm::equal_ignore_case" ref="444f53fac69e2f1e91b9b300177d2b4f" args="(const StringT &amp;str1, const StringT &amp;str2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_ignore_case</b> (const StringT &amp;str1, const StringT &amp;str2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21544fc764f56bf9af2e131b115fbd47"></a><!-- doxytag: member="Algorithm::equal_ignore_case_space" ref="21544fc764f56bf9af2e131b115fbd47" args="(const StringT &amp;str1, const StringT &amp;str2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#21544fc764f56bf9af2e131b115fbd47">equal_ignore_case_space</a> (const StringT &amp;str1, const StringT &amp;str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two string after cutting head and tail spaces out. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34bcaa8f2331a16cf2abc6f37a277215"></a><!-- doxytag: member="Algorithm::find" ref="34bcaa8f2331a16cf2abc6f37a277215" args="(const StringT &amp;str1, const StringT &amp;str2, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>find</b> (const StringT &amp;str1, const StringT &amp;str2, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00d3a1589a173329d9a39b407e237e1f"></a><!-- doxytag: member="Algorithm::rfind" ref="00d3a1589a173329d9a39b407e237e1f" args="(const StringT &amp;str1, const StringT &amp;str2, size_t pos1=StringT::npos, StrCompMode caseChk=SM_IGNORE)" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>rfind</b> (const StringT &amp;str1, const StringT &amp;str2, size_t pos1=StringT::npos, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="30a1876eb0482460a056c3f0d2e560a6"></a><!-- doxytag: member="Algorithm::multi_find" ref="30a1876eb0482460a056c3f0d2e560a6" args="(const StringT &amp;str1, const StringT &amp;str2, std::vector&lt; size_t &gt; &amp;indices, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#30a1876eb0482460a056c3f0d2e560a6">multi_find</a> (const StringT &amp;str1, const StringT &amp;str2, std::vector&lt; size_t &gt; &amp;indices, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">: Returns the number of keywords found. returnIndices contains the offsets for the keywords. If there is no such keyword, it sets the offset to -1. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d3d43dee9f6ba430a78ccff3420f5d3"></a><!-- doxytag: member="Algorithm::start_with" ref="0d3d43dee9f6ba430a78ccff3420f5d3" args="(const StringT &amp;str1, const StringT &amp;str2, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#0d3d43dee9f6ba430a78ccff3420f5d3">start_with</a> (const StringT &amp;str1, const StringT &amp;str2, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the string starts with the given key in the position pos. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f8e9305957158041cc5a845e2989e06"></a><!-- doxytag: member="Algorithm::end_with" ref="0f8e9305957158041cc5a845e2989e06" args="(const StringT &amp;str1, const StringT &amp;str2, size_t pos1=StringT::npos, StrCompMode caseChk=SM_IGNORE)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>end_with</b> (const StringT &amp;str1, const StringT &amp;str2, size_t pos1=StringT::npos, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ad0b8ced47c0e8a1f4f3b4917c83735"></a><!-- doxytag: member="Algorithm::num_occurrence" ref="0ad0b8ced47c0e8a1f4f3b4917c83735" args="(const StringT &amp;str1, const StringT &amp;str2, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#0ad0b8ced47c0e8a1f4f3b4917c83735">num_occurrence</a> (const StringT &amp;str1, const StringT &amp;str2, size_t pos1=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of occurrences for a given pattern in the string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1b3631037e8c4beb03f85e05ac27595"></a><!-- doxytag: member="Algorithm::frequency_counter" ref="f1b3631037e8c4beb03f85e05ac27595" args="(const StringT &amp;str, const std::vector&lt; StringT &gt; &amp;patterns, std::vector&lt; size_t &gt; &amp;freq, StrCompMode caseChk=SM_IGNORE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#f1b3631037e8c4beb03f85e05ac27595">frequency_counter</a> (const StringT &amp;str, const std::vector&lt; StringT &gt; &amp;patterns, std::vector&lt; size_t &gt; &amp;freq, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the counter array (reference argument) each array element representing the number of occurrences of the keyword in the patterns array. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="667249353d6a2af69417b4320f407dcd"></a><!-- doxytag: member="Algorithm::substitute_char" ref="667249353d6a2af69417b4320f407dcd" args="(CharT from, CharT to, StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#667249353d6a2af69417b4320f407dcd">substitute_char</a> (CharT from, CharT to, StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Substitute to character for from. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f35d710c0f73e1e20271697a1898fafc"></a><!-- doxytag: member="Algorithm::substitute_char" ref="f35d710c0f73e1e20271697a1898fafc" args="(CharT from, CharT to, const StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>substitute_char</b> (CharT from, CharT to, const StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#0a6aaf09e6d9d4214b5d6c86938006fb">multi_substitute_string</a> (const StringT &amp;from, const StringT &amp;to, StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Substitute the to string for from.  <a href="#0a6aaf09e6d9d4214b5d6c86938006fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6044d3ee43757fc67b0cbb91984514b0"></a><!-- doxytag: member="Algorithm::multi_substitute_string" ref="6044d3ee43757fc67b0cbb91984514b0" args="(const StringT &amp;from, const StringT &amp;to, const StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>multi_substitute_string</b> (const StringT &amp;from, const StringT &amp;to, const StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#658530c0e10cee77d1c94801efc28b1d">substitute_string</a> (const StringT &amp;from, const StringT &amp;to, const StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Substitute the to string for from.  <a href="#658530c0e10cee77d1c94801efc28b1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00d9f2c7bb54335f75c048bc2e8fa223"></a><!-- doxytag: member="Algorithm::substitute_string" ref="00d9f2c7bb54335f75c048bc2e8fa223" args="(const StringT &amp;from, const StringT &amp;to, StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>substitute_string</b> (const StringT &amp;from, const StringT &amp;to, StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b347e21063884df4bf75518e0614f00"></a><!-- doxytag: member="Algorithm::remove_newlines" ref="5b347e21063884df4bf75518e0614f00" args="(StringT &amp;str)" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>remove_newlines</b> (StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a74a400e5ca203f88bf788fc7963dcc"></a><!-- doxytag: member="Algorithm::remove_newlines" ref="1a74a400e5ca203f88bf788fc7963dcc" args="(const StringT &amp;str)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>remove_newlines</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#114fe02302e735017ae2277a1b173e96">remove_duplicate_chars</a> (StringT &amp;str, CharT c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace all the occurrences of the given characters with spaces.  <a href="#114fe02302e735017ae2277a1b173e96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe5e209fc1275c48aee815e1fdb7dc3b"></a><!-- doxytag: member="Algorithm::remove_duplicate_chars" ref="fe5e209fc1275c48aee815e1fdb7dc3b" args="(const StringT &amp;str, CharT c)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>remove_duplicate_chars</b> (const StringT &amp;str, CharT c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a7e5575ed6a557db7f4ac09d249a6de"></a><!-- doxytag: member="Algorithm::remove_multi_whitespace" ref="9a7e5575ed6a557db7f4ac09d249a6de" args="(StringT &amp;str)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>remove_multi_whitespace</b> (StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1780cd9a31bd71d8d53d555f7c3f5762"></a><!-- doxytag: member="Algorithm::remove_multi_whitespace" ref="1780cd9a31bd71d8d53d555f7c3f5762" args="(const StringT &amp;str)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>remove_multi_whitespace</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0bf91d2a040a351606db364cf9ebfbf3"></a><!-- doxytag: member="Algorithm::make_tokens_with_delimiter" ref="0bf91d2a040a351606db364cf9ebfbf3" args="(const StringT &amp;str, const StringT &amp;delimiter, std::vector&lt; StringT &gt; &amp;tokens)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#0bf91d2a040a351606db364cf9ebfbf3">make_tokens_with_delimiter</a> (const StringT &amp;str, const StringT &amp;delimiter, std::vector&lt; StringT &gt; &amp;tokens)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">: Returns an array of strings, including delimiters, each containing tokens separated by the delimiter argument. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3085971e7207d71572b7385420a55417"></a><!-- doxytag: member="Algorithm::cut_range" ref="3085971e7207d71572b7385420a55417" args="(const StringT &amp;str, size_t start, size_t end)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_range</b> (const StringT &amp;str, size_t start, size_t end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57600dafff96cfd5475f19cb12a94466"></a><!-- doxytag: member="Algorithm::cut_range" ref="57600dafff96cfd5475f19cb12a94466" args="(StringT &amp;str, size_t start, size_t end)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_range</b> (StringT &amp;str, size_t start, size_t end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#70e04500b28f3c0b0b8cc75532aa4eee">cut_delimiter</a> (const StringT &amp;str, size_t start, CharT delimiter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">string retrieval method.  <a href="#70e04500b28f3c0b0b8cc75532aa4eee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a5671eea2d1c824a20804ef9ae81d0d"></a><!-- doxytag: member="Algorithm::cut_delimiter" ref="8a5671eea2d1c824a20804ef9ae81d0d" args="(StringT &amp;str, size_t start, CharT delimiter)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_delimiter</b> (StringT &amp;str, size_t start, CharT delimiter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#5e4035b8afe3b04f371314b4e6840798">cut_between_words</a> (const StringT &amp;str, const StringT &amp;p1, const StringT &amp;p2, StrCompMode caseChk=SM_SENSITIVE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cut between the specified two patterns.  <a href="#5e4035b8afe3b04f371314b4e6840798"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2bb23f6875f069568da85e78062296c"></a><!-- doxytag: member="Algorithm::cut_between_words" ref="f2bb23f6875f069568da85e78062296c" args="(StringT &amp;str, const StringT &amp;p1, const StringT &amp;p2, StrCompMode caseChk=SM_SENSITIVE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_between_words</b> (StringT &amp;str, const StringT &amp;p1, const StringT &amp;p2, StrCompMode caseChk=SM_SENSITIVE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0838d9b4f348935e22b12563f0b32176"></a><!-- doxytag: member="Algorithm::cut_word_after" ref="0838d9b4f348935e22b12563f0b32176" args="(const StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_word_after</b> (const StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4ec6d907ba268d826af8aaeba026c914"></a><!-- doxytag: member="Algorithm::cut_word_after" ref="4ec6d907ba268d826af8aaeba026c914" args="(StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_word_after</b> (StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a054d95e87397ed7023256ec1e766e4a"></a><!-- doxytag: member="Algorithm::cut_line_after" ref="a054d95e87397ed7023256ec1e766e4a" args="(const StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_line_after</b> (const StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad27aa1fdeee7b587caeb7ea1fd0efd6"></a><!-- doxytag: member="Algorithm::cut_line_after" ref="ad27aa1fdeee7b587caeb7ea1fd0efd6" args="(StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cut_line_after</b> (StringT &amp;str, const StringT &amp;tag, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="608f3b14b1fc1f2da645f17ec11246f4"></a><!-- doxytag: member="Algorithm::take_between_marks" ref="608f3b14b1fc1f2da645f17ec11246f4" args="(const StringT &amp;str, CharT beg, CharT end, std::vector&lt; StringT &gt; &amp;arrayOfstrings)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#608f3b14b1fc1f2da645f17ec11246f4">take_between_marks</a> (const StringT &amp;str, CharT beg, CharT end, std::vector&lt; StringT &gt; &amp;arrayOfstrings)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">: Returns n DynamicArray of StringTs of which elements contain the words between the marks. It doesn't contain the marks itself. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e5fb413e10c74a15ad845d55033532ee"></a><!-- doxytag: member="Algorithm::take_between_mark" ref="e5fb413e10c74a15ad845d55033532ee" args="(const StringT &amp;str, CharT mark, std::vector&lt; StringT &gt; &amp;arrayOfstrings)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#e5fb413e10c74a15ad845d55033532ee">take_between_mark</a> (const StringT &amp;str, CharT mark, std::vector&lt; StringT &gt; &amp;arrayOfstrings)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">: Returns n DynamicArray of strings of which elements contain the words between the marks. It doesn't contain the marks itself. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb7b68dc4465cc781c42c92859807cab"></a><!-- doxytag: member="Algorithm::reverse_cut_rear_with" ref="cb7b68dc4465cc781c42c92859807cab" args="(const StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#cb7b68dc4465cc781c42c92859807cab">reverse_cut_rear_with</a> (const StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the rear part that begins with the tag, including the tag depending on the option. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="822b25f8be062758f30ae2a466c9ba9a"></a><!-- doxytag: member="Algorithm::reverse_cut_rear_with" ref="822b25f8be062758f30ae2a466c9ba9a" args="(StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_cut_rear_with</b> (StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="410bae390e6e6bcf16578718e2ac5aae"></a><!-- doxytag: member="Algorithm::reverse_cut_front_with" ref="410bae390e6e6bcf16578718e2ac5aae" args="(const StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_cut_front_with</b> (const StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6fb647cfad98ebf7d9ea6fb15c1a99ae"></a><!-- doxytag: member="Algorithm::reverse_cut_front_with" ref="6fb647cfad98ebf7d9ea6fb15c1a99ae" args="(StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_cut_front_with</b> (StringT &amp;str, CharT tag, bool includeTag=false, StrCompMode caseChk=SM_IGNORE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="408ada0c548f1efe5437092a030ad3a8"></a><!-- doxytag: member="Algorithm::compact_head" ref="408ada0c548f1efe5437092a030ad3a8" args="(const StringT &amp;str)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>compact_head</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cecd9de0fd80290980dd73ab23517844"></a><!-- doxytag: member="Algorithm::compact_head" ref="cecd9de0fd80290980dd73ab23517844" args="(StringT &amp;str)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#cecd9de0fd80290980dd73ab23517844">compact_head</a> (StringT &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cut trailing spaces in the tail. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e6276cd46260bf390528f3912f45219"></a><!-- doxytag: member="Algorithm::compact_tail" ref="5e6276cd46260bf390528f3912f45219" args="(const StringT &amp;str)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>compact_tail</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e53ee74a9acd0c38f05e9165b0793b12"></a><!-- doxytag: member="Algorithm::compact_tail" ref="e53ee74a9acd0c38f05e9165b0793b12" args="(StringT &amp;str)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>compact_tail</b> (StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25e7102a43f8619c1bb4267fc73b2336"></a><!-- doxytag: member="Algorithm::compact" ref="25e7102a43f8619c1bb4267fc73b2336" args="(const StringT &amp;str)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>compact</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e270ae897f5dda1b8e2d007913f777bd"></a><!-- doxytag: member="Algorithm::compact" ref="e270ae897f5dda1b8e2d007913f777bd" args="(StringT &amp;str)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>compact</b> (StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de1ad223dfbe083fef46669426ccf599"></a><!-- doxytag: member="Algorithm::trim" ref="de1ad223dfbe083fef46669426ccf599" args="(const StringT &amp;str)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>trim</b> (const StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bde58525e896a9335411f68393f87d10"></a><!-- doxytag: member="Algorithm::trim" ref="bde58525e896a9335411f68393f87d10" args="(StringT &amp;str)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>trim</b> (StringT &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c4fed76db6affd3bfa4217b1bf57744e"></a><!-- doxytag: member="Algorithm::read_from_file" ref="c4fed76db6affd3bfa4217b1bf57744e" args="(const char *filename, std::vector&lt; StringT &gt; &amp;lines, CharT line='\n')" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>read_from_file</b> (const char *filename, std::vector&lt; StringT &gt; &amp;lines, CharT line='\n')</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2b2c0788b3dbb1521eae8685478aa2e"></a><!-- doxytag: member="Algorithm::write_to_file" ref="a2b2c0788b3dbb1521eae8685478aa2e" args="(const char *filename, const std::vector&lt; StringT &gt; &amp;lines)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>write_to_file</b> (const char *filename, const std::vector&lt; StringT &gt; &amp;lines)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html#7f3d9af1b1567546161c773696660c5f">read_filenames</a> (const StringT &amp;dir, std::vector&lt; StringT &gt; &amp;files)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read all the names of the files in the specified directory.  <a href="#7f3d9af1b1567546161c773696660c5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa3287000daf77817025b444b951af77"></a><!-- doxytag: member="Algorithm::generate_random_string" ref="fa3287000daf77817025b444b951af77" args="(size_t size)" -->
static StringT&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_random_string</b> (size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f51c5e010fd029995daabff0ba2dd224"></a><!-- doxytag: member="Algorithm::read_from_encode" ref="f51c5e010fd029995daabff0ba2dd224" args="(const char *encode_type, const char *input, size_t len, StringT &amp;output)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>read_from_encode</b> (const char *encode_type, const char *input, size_t len, StringT &amp;output)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="71b0e9191bc505859f1b6d4d50cb9a16"></a><!-- doxytag: member="Algorithm::write_to_encode" ref="71b0e9191bc505859f1b6d4d50cb9a16" args="(const char *encode_type, char **output, size_t &amp;len, const StringT &amp;input)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>write_to_encode</b> (const char *encode_type, char **output, size_t &amp;len, const StringT &amp;input)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2089d52191fd52e7cf0d6574ad72212b"></a><!-- doxytag: member="Algorithm::release" ref="2089d52191fd52e7cf0d6574ad72212b" args="(char *p)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>release</b> (char *p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1bda1a6c7890a94c5b5e3a687965bfe4"></a><!-- doxytag: member="Algorithm::display" ref="1bda1a6c7890a94c5b5e3a687965bfe4" args="(const StringT &amp;str, const char *encode_t=&quot;UTF&#45;8&quot;, std::ostream &amp;os=std::cout)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display</b> (const StringT &amp;str, const char *encode_t=&quot;UTF-8&quot;, std::ostream &amp;os=std::cout)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class StringT = std::string, class IS_NUMERIC = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET = is_alphabet&lt;typename StringT::value_type&gt;&gt;<br>
 class Algorithm&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;</h3>

An string algorithm set. 
<p>
It is an algorithm set about string. Temlate parameter StringT indicates the string type. IS_NUMERIC indicates a class about deciding if it is a numeric. IS_ALPHABET is a class to judge about charactors in alphabet. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00132">132</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5e4035b8afe3b04f371314b4e6840798"></a><!-- doxytag: member="Algorithm::cut_between_words" ref="5e4035b8afe3b04f371314b4e6840798" args="(const StringT &amp;str, const StringT &amp;p1, const StringT &amp;p2, StrCompMode caseChk=SM_SENSITIVE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static StringT <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::cut_between_words           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrCompMode&nbsp;</td>
          <td class="paramname"> <em>caseChk</em> = <code>SM_SENSITIVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cut between the specified two patterns. 
<p>
Cut between the specified two patterns. The return values starts with the first pattern and ends with the second one. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00943">943</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="70e04500b28f3c0b0b8cc75532aa4eee"></a><!-- doxytag: member="Algorithm::cut_delimiter" ref="70e04500b28f3c0b0b8cc75532aa4eee" args="(const StringT &amp;str, size_t start, CharT delimiter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static StringT <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::cut_delimiter           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&nbsp;</td>
          <td class="paramname"> <em>delimiter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
string retrieval method. 
<p>
string retrieval method. Returns the string from start to right before the delimiter character. Does not affect the receiver itself. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00902">902</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9f7fcee0cfbabce55c5a9cabb1868f29"></a><!-- doxytag: member="Algorithm::KMP" ref="9f7fcee0cfbabce55c5a9cabb1868f29" args="(const StringT &amp;text, const StringT &amp;pattern, StrCompMode caseChk=SM_SENSITIVE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::KMP           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrCompMode&nbsp;</td>
          <td class="paramname"> <em>caseChk</em> = <code>SM_SENSITIVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
KMP, an string maching algorithm. caseChk could be SM_SENSITIVE or SM_IGNORE. Return the index of the first instance of pattern started from 0. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00171">171</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="0a6aaf09e6d9d4214b5d6c86938006fb"></a><!-- doxytag: member="Algorithm::multi_substitute_string" ref="0a6aaf09e6d9d4214b5d6c86938006fb" args="(const StringT &amp;from, const StringT &amp;to, StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::multi_substitute_string           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrCompMode&nbsp;</td>
          <td class="paramname"> <em>caseChk</em> = <code>SM_IGNORE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Substitute the to string for from. 
<p>
Substitute the to string for from. Beware that it will substitute as many times as necessary. Returns the resulting string. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00694">694</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="7f3d9af1b1567546161c773696660c5f"></a><!-- doxytag: member="Algorithm::read_filenames" ref="7f3d9af1b1567546161c773696660c5f" args="(const StringT &amp;dir, std::vector&lt; StringT &gt; &amp;files)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::read_filenames           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; StringT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>files</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read all the names of the files in the specified directory. 
<p>
Read all the names of the files in the specified directory. If there are any errors such as no such directory, it just returns leaving the reference argument unchanged. It discards '.' and '..' files. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l01310">1310</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="114fe02302e735017ae2277a1b173e96"></a><!-- doxytag: member="Algorithm::remove_duplicate_chars" ref="114fe02302e735017ae2277a1b173e96" args="(StringT &amp;str, CharT c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::remove_duplicate_chars           </td>
          <td>(</td>
          <td class="paramtype">StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace all the occurrences of the given characters with spaces. 
<p>
Replace all the occurrences of the given characters with spaces. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00809">809</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="a3e24e19980c0dd29c80f9feff6e5191"></a><!-- doxytag: member="Algorithm::rKMP" ref="a3e24e19980c0dd29c80f9feff6e5191" args="(const StringT &amp;text, const StringT &amp;pattern, StrCompMode caseChk=SM_SENSITIVE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::rKMP           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrCompMode&nbsp;</td>
          <td class="paramname"> <em>caseChk</em> = <code>SM_SENSITIVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
KMP, an string maching algorithm. caseChk could be SM_SENSITIVE or SM_IGNORE. It searches from back. Return the index of the first instance of pattern started from 0. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00254">254</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="658530c0e10cee77d1c94801efc28b1d"></a><!-- doxytag: member="Algorithm::substitute_string" ref="658530c0e10cee77d1c94801efc28b1d" args="(const StringT &amp;from, const StringT &amp;to, const StringT &amp;str, size_t pos=0, StrCompMode caseChk=SM_IGNORE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static StringT <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::substitute_string           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrCompMode&nbsp;</td>
          <td class="paramname"> <em>caseChk</em> = <code>SM_IGNORE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Substitute the to string for from. 
<p>
Substitute the to string for from. Beware that it will substitute only one time! Returns the resulting string. Aborts if there is no 'from' string. 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00752">752</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="617415dba55cc4533e4776760178032b"></a><!-- doxytag: member="Algorithm::to_lower" ref="617415dba55cc4533e4776760178032b" args="(const StringT &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static StringT <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::to_lower           </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change all the upper case to lower case in the _text. 
<p>
Change all the upper case to lower case in the _text. It forces const char* to char*. Do more research on std::string 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00416">416</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="42e06428b21a425ac2da8d60313ab9a9"></a><!-- doxytag: member="Algorithm::to_upper" ref="42e06428b21a425ac2da8d60313ab9a9" args="(StringT &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StringT  = std::string, class IS_NUMERIC  = is_numeric&lt;typename StringT::value_type&gt;, class IS_ALPHABET  = is_alphabet&lt;typename StringT::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classAlgorithm.html">Algorithm</a>&lt; StringT, IS_NUMERIC, IS_ALPHABET &gt;::to_upper           </td>
          <td>(</td>
          <td class="paramtype">StringT &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change all the lower case to upper caes in the _text. 
<p>
Change all the lower case to upper caes in the _text. It forces const char* to char*. Do more research on std::string 
<p>Definition at line <a class="el" href="algo_8hpp-source.html#l00401">401</a> of file <a class="el" href="algo_8hpp-source.html">algo.hpp</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/home/Kevin/izenelib/include/am/istring/<a class="el" href="algo_8hpp-source.html">algo.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 10 15:35:55 2009 for iZENElib - A great library for text processing by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
